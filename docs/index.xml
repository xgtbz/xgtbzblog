<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://xgtbz.github.io/xgtbzblog/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Apr 2024 13:54:05 +0100</lastBuildDate><atom:link href="https://xgtbz.github.io/xgtbzblog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Physical to Virtual Mapping</title>
      <link>https://xgtbz.github.io/xgtbzblog/posts/virtual-physical-mapping/</link>
      <pubDate>Sun, 21 Apr 2024 13:54:05 +0100</pubDate>
      
      <guid>https://xgtbz.github.io/xgtbzblog/posts/virtual-physical-mapping/</guid>
      
      <description>Preliminary In this short blog post, we will be dissecting the innards of routines such as MmMapLockedPages and MmMapIoSpace to understand how the Virtual Memory Manager (VMM) maps physical memory to the kernel virtual address (VA) space at a high level. Mapping physical memory is a powerful technique that can be utilised for several purposes, such as overwriting read only virtual memory without changing the protection, and updating paging structures themselves.</description>
      
    </item>
    
    <item>
      <title>Virtual Method Table Hook</title>
      <link>https://xgtbz.github.io/xgtbzblog/posts/vmt-hook/</link>
      <pubDate>Tue, 19 Dec 2023 21:44:49 +0100</pubDate>
      
      <guid>https://xgtbz.github.io/xgtbzblog/posts/vmt-hook/</guid>
      
      <description>Preliminary Virtual method tables (aka VMTs, vtables, vftables or dispatch tables) are an array of pointers to virtual methods of a class. They contain all the class&amp;rsquo;s dynamically bound functions (virtual functions), and they are used to implement dynamic dispatch - which is deciding which implementation of a polymorphic operation should be called at run-time. These tables exist at a class level, meaning multiple instances (objects with identity) of the same class share the same VMT.</description>
      
    </item>
    
    <item>
      <title>Vulnerable Driver Reversal</title>
      <link>https://xgtbz.github.io/xgtbzblog/posts/vulnerable-driver-reversal/</link>
      <pubDate>Wed, 01 Nov 2023 21:44:49 +0100</pubDate>
      
      <guid>https://xgtbz.github.io/xgtbzblog/posts/vulnerable-driver-reversal/</guid>
      
      <description>Preliminary Any driver that communicates with a user-mode application is potentially vulnerable. The privileges exposed by a driver through communication are not exclusively limited to a specific user-mode application (unless the driver takes an extra step to validate a specific process, which is rare), therefore they can be reverse engineered, exploited and leveraged by any program running in ring3. In the past, malware developers have exploited vulnerable drivers to manipulate MSRs, allocate RWX memory in the kernel virtual address space to execute shellcode, patch system calls, or even manually map an unsigned driver - this blog post demonstrates nothing new.</description>
      
    </item>
    
  </channel>
</rss>
