+++
title = 'Virtual Method Table Hook'
date = 2023-12-19T21:44:49+01:00
draft = false
+++


## Preliminary

Virtual method tables (aka `VMTs`, `vtables`, `vftables` or dispatch tables) are an array of pointers to virtual methods of a class. They contain all the class's dynamically bound functions (virtual functions), and they are used to implement dynamic dispatch - which is deciding which implementation of a polymorphic operation should be called at run-time. These tables exist at a class level, meaning multiple instances (objects with identity) of the same class share the same `VMT`. In this blog, you will learn about devirtualisation, what dynamic dispatch is, how to exploit/hook `VMTs`, understand virtual destructors and virtual pointers, learn about the flaws of dynamic dispatch within C++ and how these virtual function tables are used to implement dynamic dispatch.

## Binding/Dispatching

Binding (aka dispatching) is simply associating a function call with its definition. Static binding is when a function call is associated with its definition during compile time, and dynamic binding during run-time. As we all know, a virtual function can be overridden in a derived class. Therefore, the compiler cannot statically bind a virtual function, because it does not know which implementation should be called. For example, if a derived class, that has overridden a virtual function that was inherited from a base class, is created through an interface of a base class, the implementation of the virtual function that would be called would be the one defined in the base class, which would be erroneous. Hence why virtual functions cannot be statically bound. To further understand, let's look at a code example in which a function would be statically bound:

```cpp
struct Example
{
   [[noreturn]] void IsEven(int Number) const noexcept(true)
   {
     std::cout << ( ( Number % 2 ) ? "Is Odd" : "Is Even" );
   }
}
```

Here, there is only one instance of `IsEven`, and attempting to override it will lead to undefined behaviour since it's not virtual. So there's no ambiguity about which implementation of the function should be called, because only one implementation exists, so this function can be bound early at compile time (static binding). So in this scenario, the compiler will not generate a virtual method table associated with the structure. Now, let's examine a scenario in which a `VMT` would be generated by the compiler, and the function would be dynamically bound: 

```cpp
class Animal
{
public:
   virtual void Speak()
   {
     std::cout << "I am an animal\n";
   }
};

class Dog : public Animal
{
public:
   virtual void Speak() override
   {
     std::cout << "I am a dog\n";
   }
};

int main()
{
  Animal* my_animal = new Dog();
  my_animal->Speak();
  delete my_animal;
}
```
In the code above, we have a concrete base class with a public virtual method, in which a concrete derived class inherits and overrides. In the main function, the derived class is constructed with dynamic storage duration, but manipulated through an object of the base class. From a compiler perspective, `my_animal` points to an object of type Animal, so if this was statically bound, the implementation of the virtual method associated with the function call would be the one from the base class, which is incorrect. Thanks to dynamic dispatch/binding, `my_animal->Speak()` actually returns to us the output: "I am a dog", which is what we should expect. In upcoming chapters, we'll learn how this is implemented beneath the surface, but for now we'll shift our focus to virtual destructors and the drawbacks associated with the code above.

## Virtual Destructors

To understand virtual destructors practically, we should define a synthesised destructor and a non-parameterised constructor explicitly for each of our concrete classes. Keep in mind the code below is written within the scope of the class that they belong to, but to be succinct I won't include the whole class's definition as it is already above, likewise with the main function. 

```cpp
 Animal() {
    std::cout << "Animal constructor called\n";
  }

 ~Animal() {
    std::cout << "Animal destructor called\n";
 }
    
 Dog() {
    std::cout << "Dog constructor called\n";
 }

 ~Dog() {
    std::cout << "Dog destructor called\n";
 }
```
Let's see what happens when we execute the code in the main function. We should be expecting each object to be constructed, and then destructed in the reverse order of construction.

```
Output:
Animal Constructor called
Dog Constructor called
I am a dog
Animal destructor called
```

As we see above, the constructors of each class is called, but the destructor of the dynamic type (Dog) of the polymorphic object is not called. This arises from the fact that the destructor is not virtual, so it is statically bound. Similar to what was mentioned earlier, the compiler believes that `my_animal` points to an object of type `Animal`, so it calls the destructor for only this, which leads to undefined behaviour, because both objects were constructed and so it is often the case that both objects need the chance deallocate/close any scope-bound resources they have allocated in their lifetime. However, explicitly marking the destructor virtual of a base class instructs the compiler to try and call the child's destructor by adding the destructor to the `VMT` of the class. So far, we've mentioned `VMTs` briefly and you've been presented with a basic definition in the introduction. We'll now look at their implementation, which will solidify your understanding of virtual destructors.

## Virtual Method Tables and Devirtualisation

Mentioned briefly in the introduction, virtual method tables are just a static array of pointers to virtual functions, set-up at compile time. The compiler constructs a `vtable` for every class with virtual methods, and there is one virtual table that is shared by all instances (objects) of the class. Virtual functions are added to the `VMT` in the order they were declared, so the first virtual function will be at index 0, the second at index 1, the third at index 2 and so on. Each entry points to the most derived virtual function accessible by that class. Let's update our code to look at an example. First, we should get rid of the constructors/ destructors we've explicitly defined and remove the virtual keywords from any function. We should also add fields to our base class, as we will be reviewing its layout in memory. Then, we should initialise an object of type `Animal` and print it's memory location. At the end, the code should look like this: 

```cpp
class Animal
{
public:
    int Weight { 50 };
    bool InZoo { false };

    void Speak()
    {
        std::cout << "I am an animal\n";
    }
};

class Dog : public Animal
{
public:
    void Speak()
    {
        std::cout << "I am a dog\n";
    }
};

int main()
{
    Animal my_animal = Dog::Dog();
    my_animal.Speak();

    std::cout << std::hex << &my_animal << std::endl;
    system("pause>0");
}
```
Now our `Animal` class is no longer polymorphic. It doesn't have any virtual functions, so the compiler does not generate a `vtable` for it at compile time. In memory, our structure looks like this ( Using the layout: offset, size, address, value ): 

> ```
> Unnamed Structure:
> → 0000 - 4 Bytes 628CAFF908 : 50
> → 0004 - 4 Bytes 628CAFF90C : 0
> → 0008 - 4 Bytes 628CAFF910 : 0xCCCCCCCC 
> → 0010 - 4 Bytes 628CAFF914 : 0xCCCCCCCC 
> → 0014 - 4 Bytes 628CAFF918 : 0xCCCCCCCC 
> ...
> ```

We can see the first 4 bytes hold the value 50, to represent the first field known as "Weight". The second 4 bytes, directly adjacent to the first field, is our second field of the class, the `boolean` value to represent "InZoo". After these two fields, there's a bunch of 0xCC bytes to represent `unintialised stack memory`. This is exactly what we'd expect. Now let's make one small adjustment to our code - we should mark every function from both the derived and base class virtual. Once we've done this, we should look at our structure in memory:

> ```
> Animal:
> → 0000 - Pointer to Autocreated from 7ff7bb9bbcb0 64d291f6a8 : P->7ff7bb9bbcb0
> → 0008 - 4 Bytes 64d291f6b0 : 50
> → 000C - 4 Bytes 64d291f6b4 : 0
> → 0010 - 4 Bytes 64d291f6b8 : 0xCCCCCCCC 
> ...
> ```

Weirdly, we see that our structure begins with a "Pointer to Autocreated" that we didn't explicitly define, then, our two fields down below. This pointer is known as the `virtual pointer`, and it points to the virtual method table for the class. It is added to the start of each polymorphic class along the inheritance hierarchy by the compiler, and it increases the size of the class by `sizeof(vptr)` (in this case it doubles the size of our structure). For us, the `VMT` array only consists of one function, since our class only has one virtual function `(Speak)`.

> ```
> Animal:
> ↓ 0000 - Pointer to Autocreated from 7ff7bb9bbcb0 64d291f6a8 : P->7ff7bb9bbcb0
>     → 0000 - Pointer 7ff7bb9bbcb0 : P->0x7ff659F114d
> ```



So to clarify, the address `0x64d291f6a8` is the address of the virtual pointer, the first field of our class added by the compiler. The virtual pointer points to the address `0x7ff7bb9bbcb0`, which is our virtual function table/array. We can see that the first element of this array is `0x7ff659f114d`, which should represent our virtual `Speak()` method. Let's disassemble it to make sure: 

```asm
E9 98100000 jmp Animal::Speak
```
It is in `RX` memory and we can see it points to a small `stub` that jumps to our virtual function, whose disassembly looks like this: 

```nasm
mov qword ptr ss:[rsp + 8], rcx
push rbp
push rdi
rub rsp, E8
lea rbp, qword ptr ss:[rsp + 20]
lea rcx, qword ptr ds:[<__0628ED20__appname@cpp>]
call 0x7ff6a560142e
lea rdx, qword ptr ds:[<"I am an animal\n"...>]
mov rcx, qword ptr ds:[<class std::basic_ostream>]
call 0x7ff6a560108c
```

We can see the disassembly corresponds to the the `Speak()` virtual function, so we are in the right direction. However, our virtual function takes no arguments, so what is `RCX` pointing to? Well, if you understand calling conventions you'd know that all `non-static` member class functions adhere to the `__thiscall` calling convention on `x86`, in which the `this` pointer is implicitly passed as an argument on the stack to each one of these functions. In `x64`, the `__thiscall` calling convention is ignored, and instead the `__fastcall` register-based convention is used in which the `this` pointer is implicitly passed as an argument through the `RCX` register instead of the stack. So, so far, we understand that when a virtual function is called, the virtual pointer is consulted to give us the virtual method table, which is then indexed to return to us our virtual function. Let's put a hardware breakpoint on our `vtable` and call the virtual method `Speak()` to corroborate this.

Unexpectedly, we see our `HWBP` on the `vtable` is never hit even after we call the virtual `Speak()` function. Even when we use `SLAT` with a hypervisor to log accesses to the `vtable`, we get no results. We still get the output: "I am an animal", so why is this virtual function being statically bound rather than dynamically through the use of `vtables`? The reason for this behaviour is known as `devirtualisation`, the compiler can call the correct virtual function without reading the vtable. Let's go back to our main function and inspect the code:

```cpp
int main()
{
    Animal my_animal = Dog::Dog();
    my_animal.Speak();

    std::cout << std::hex << &my_animal << std::endl;
    system("pause>0");
}
```

We see that `my_animal` has `automatic storage duration`, it is not a pointer. Therefore, the static type of `my_animal` (which is the data type of the object at compile-time) is the same as the `run-time` type. For this reason, devirtualisation occurs; `my_animal` is not a pointer so it's `run-time` type is known at compile time, so vtables don't need to be consulted to find the correct implementation of `Speak()` because it is already known by the compiler. If `my_animal` had dynamic storage duration and so a type of `Animal*` rather than `Animal`, then the function could not be statically bound because the type of the object pointed to by a pointer is a `run-time` property, so the `VMT` `breakpoint` would be hit. Devirtualisation is an optimisation, because virtual method calls are a lot slower than direct calls - we'll look at why this is the case later. So from this we can infer, that `run-time` polymorphism (searching the vtable to find the correct virtual function) only happens with pointer types, in which the `run-time type` of the object being pointed to differs from it's static type. Let's look at an example in which `vtables` would really be used:

```cpp
int main()
{
    Animal* my_animal = new Dog;
    my_animal->Speak();
	
    delete my_animal;
    system("pause>0");
}
```

Here, `my_animal` has dynamic storage duration, it is allocated on the `free store`. It is not temporary, and therefore it does not destruct unless we delete it.  Devirtualisation cannot happen - the type of the object pointed to by a pointer is only known at `run-time`. In this scenario, when we place our `HWBP` on the `vtable`, control is transferred to the debugger as expected, showing a virtual call (rather than a direct call) has occurred, and "I am a dog" is printed rightly. Now let's shift our focus back to virtual destructors. Marking a destructor of a base class virtual appends it to the vtable so it is dynamically bound, ensuring that the derived class is properly destructed. In other languages such as rust, the virtual destructor of a polymorphic object is added to the `VMT` automatically, but C++ allows us to avoid the overhead associated with calling a trivial destructor for a derived class solely for the sake of coherency.

## Flaws of Dynamic Dispatch

Calls to virtual functions are relatively slow compared to inline or direct calls. First, the class object is dereferenced to give us the location of the virtual pointer. Then, the virtual pointer is dereferenced to give us our virtual method table. Then, we use pointer arithmetic to index into the `VMT` to get our target virtual function; you can understand why it's so slow. There are 3 layers of indirection. The table I've constructed below shows the flow of a virtual call:

![Image](https://i.ibb.co/kKSYXQv/vmt-flow-Photoroom-png-Photoroom.png)

Now we should understand the reason for the devirtualisation optimisation - the compiler should avoid virtual calls when a direct call is possible ( when the object is not a pointer or reference, so it's static type is the same at `run-time` ). Not only is it slow, the virtual pointer added to our class increases the size, so our structure takes up more space in memory. `VMTs` are also easily exploitable, they can be cloned, patched or even replaced entirely. We'll look at how this is done in the next chapter.

## Hooking the virtual method table

Hooking a `vtable` is just replacing the `stub/thunk` with your target function. We mentioned earlier that the `vtable` is in `RX` memory, so we must change it's protection before we patch it and restore the protection. Below is a code example of what we've just described:

```cpp
// this is the function we will be replacing the virtual function with
void replace_function()
{
    std::cout << "hooked!!!\n";
}

int main()
{
    Animal* my_animal = new Dog;

    // class -> vpointer -> vtable
    auto vTable = *reinterpret_cast<void***>(my_animal);

    // change protection to rwx (just needs to be writable)
    DWORD oldProtection{};
    VirtualProtect(vTable, sizeof(void*), PAGE_EXECUTE_READWRITE, &oldProtection);

    // index into the vtable and patch our function
    // 1st virtual function at index 0, second at index 1, third at index 2... etc
    vTable[0] = replace_function;

    // restore the protection
    VirtualProtect(vTable, sizeof(void*), oldProtection, &oldProtection);

    // test by calling virtual function
    my_animal->Speak();

    system("pause>0");
  
}
```

```
Output:
"hooked!!!"
```

Evidently, we have been successful in hooking the `vtable`. So we know this works well when we are able to change the protection of the `vtable`, but this isn't always the case. A solution to this is cloning the `vtable` and installing our hook in this new table. Then, we set our `vpointer` to point to the new table. This way, we don't have to worry about changing the protection of our `VMT`:

```cpp
    // class -> vpointer -> vtable
    void** vTable = *reinterpret_cast<void***>(my_animal);
    void*& vPointer = *reinterpret_cast<void**>(my_animal);

    // get the size of the vtable
    size_t vTable_size{};
    do (vTable_size += 1);
    while (vTable[vTable_size] != nullptr);

    // allocate space for our new vtable
    auto new_vTable = new void* [vTable_size];

    // clone the contents
    memcpy(new_vTable, vTable, sizeof(void*) * vTable_size);

    // hook our new vtable
    new_vTable[0] = replace_function;

    // update vpointer
    vPointer = new_vTable;
```

This method is great when we can't change the protection, but if we want our hook to remain, we must work on ensuring it's not detected by an anti-cheat. We will look at how to do this in the next chapter.

## Leveraging devirtualisation to avoid hook recursion

Replacing entries in these tables are extremely easy, but this type of exploitation is even easier to detect, simply because the behaviour returned to the program differs from what is expected. For example, when `Speak()` is called, we expect "I am a dog\n" to be printed, not "hooked!!!". So our job is to emulate the function and produce something with similar or identical semantics, almost 1:1 with the original function so an anti-cheat isn't suspicious that the function has been replaced. However, since it is not always the case that we have the definition/implementation for the function we are sometimes incapable of emulating it. It would be much more reasonable to just call the original function normally in our `replace_function` and redirect execution to where it should be, so nothing malicious is surmised by an anti-cheat. This is possible to do because the `this` pointer is passed implicitly as an argument to all member functions through the `RCX` register. This solution seems optimal at first, but calling the original function would result in a virtual call, in which whatever is stored in the `VMT` (which we have patched) would be called, so we would just jump back to our hook, and we're then left with an infinite recursion issue that'd lead to a stack overflow.

> **Image may be more clear with light mode**

![Image](https://i.ibb.co/P594fhy/save-hook-recursiob-Photoroom-png-Photoroom.png)

So, to circumvent this issue, we get the `run-time` type of the object pointed to by the `this` pointer using reflection ( `typeid` operator ), and then we construct an object of the same type with automatic storage duration. We then call the function we've replaced using the object we just created, forcing the compiler to use devirtualisation rather than a virtual call, because the type of the object will always be the same, regardless of whether it's `run-time` or not. This way, the `vtable` isn't consulted to look for the virtual function, so the function that will be called will not be our `replace_function`, but rather the actual virtual function (since it's a direct call). We have to update all the fields of the object we just created to match the object on which the virtual function was called, because the virtual function may operate on this data. We could do this by checking if it's copy constructible, but if it isn't we should just copy it out manually. We don't want the object to be moved, because want the `this` pointer to point to valid data (if it was moved it'd be a dangling pointer). Let's update our `replace_function` to do this

```cpp
// 'this' passed through RCX (first argument)
void replace_function(Animal* thisptr)
{
    std::cout << "hooked!!!\n";

    // if the run-time type of object pointed to by the pointer is an Animal then...
    if (std::string(typeid(*thisptr).name()).find("Animal") 
            != std::string::npos)
    {
        // we create an object that is NOT a pointer, so no virtual calls...
        Animal replace_rtt{};

        // update the state to match
        replace_rtt.Weight = thisptr->Weight;
        replace_rtt.InZoo = thisptr->InZoo;

        // call the function, force devirtualisation, no infinite recursion... no stack overflow
        replace_rtt.Speak();

    }
    else {
        // in this case, the 'this' pointer points to an object of type Dog during run-time

        // same process, but we have to use the correct type so the right implementation of Speak is called
        Dog replace_rtt{};

        replace_rtt.Weight = thisptr->Weight;
        replace_rtt.InZoo = thisptr->InZoo;

        // call the function, force devirtualisation, no infinite recursion... no stack overflow
        replace_rtt.Speak();
    }
}
```

```
Output:
hooked!!!
I am a dog
```
It's important to get the type of the object pointed to by the pointer at `run-time`, and not the type of the pointer - which will never change. `Animal*` can point to a `Dog` or `Animal`. The code below is erroneous for these reasons:

```cpp
// logical error : decltype evaluates type at compile time
std::remove_reference<decltype(*thisptr)>::type rtt{};
rtt.Speak();

// logical error: typeid(thisptr).name() will always return Animal*, we need the type of the object pointed to by this pointer
if (std::string(typeid(thisptr).name()).find("Animal") != std::string::npos)
```

## Conclusion

Now you should understand how dynamic dispatch is implemented in C++, and how you can hook/clone `VMTs` without changing the protection. You should also know how to redirect execution flow back to the original function you've hooked without ending up with a stack overflow by utilising the devirtualisation optimisation. When this isn't possible, you could of-course save the original function pointer before you hook the `VMT`.